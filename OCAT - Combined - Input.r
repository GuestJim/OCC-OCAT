#	this script is for reading in CSV data and then passing the desired information to the Output script
library(readr)
#	loads the readr library, used to read in the CSVs as data frames
library(ggplot2)
#	loads the ggplot2 library, used for creating plots/graphs
library(moments)
#	loads the moments library, used for certain functions involving probability distribution moments

game	=	"!GAME!"
cGPU	=	!GPU!
#	variables to hold the game name and current GPU
#		for multi-GPU scenarios, cGPU will be NULL

gameF	=	gsub(":", "-", game)
#	creates a file-name safe version of the game name, replacing colons with dashes
gameF	=	unlist(strsplit(gameF, split=" [(]"))[1]
#	splits the gameF variable at opening parantheses returns just the beginning portion

theme_set(theme_grey(base_size = 16))
#	sets the base size for features in the ggplots2 theme
#		by raising it to 16, text will be larger
DPI			=	120
#	sets the DPI for saving graphs
ggdevice	=	"png"
#	ggplots2 can be saved as multiple formats, this sets it for PNG
#		can also use PDF, but typically PNGs are desired

#	below are a series of switches for various things
useSHORT	=	TRUE
#	controls if the shortened versions of the location and API names should be used
testAPI		=	FALSE
#	provides an override for if multiple APIs were involved in the test
#	when FALSE it does the usual behavior of checking if multiple APIs are involved
#	when TRUE it will not check the number of APIs and will act as though there are multiple regardless
listFPS		=	NULL
#	for adding to the FPS Percentile list
#		default list is 60, 50, 30, 20, 15
#		NULL will have none added
diffLim		=	NULL
#	for creating a version of the Consecutive Difference graph with an extended Y (difference) scale
#		it wants a frame time
QUAN		=	c(0.01, 0.99)
#	controls the quantiles used for the QQ line in the QQ plots
FtimeLimit	=	1000/15
#	upper frame time limit for graphs
yratesEXT	=	NULL
#	for adding more frame rates to the list used for scale breaks
#		the rates are converted to times for the scales; rates are just a bit easier to work with

gWIDTH	=	8
gHEIGH	=	9
#	graph width and height
app.BREAK	=	FALSE
#	switch for if line breaks should be used in the scale labels (including secondary axes)
#		can be changed prior to graphs being created for selective application

textOUT		=	TRUE
#	controls if any of the text output is produced
HTMLOUT		=	TRUE
#	controls if any of the HTML output is produced
graphs		=	TRUE
#	controls if the faceted graphs are created
graphs_all	=	FALSE
#	controls if the individual graphs are created

textFRAM	=	TRUE
graphFRAM	=	TRUE
#	controls if the frame time-based outputs should be created

textDISP	=	FALSE
graphDISP	=	FALSE
#	controls if the display time-based outputs should be created

textREND	=	FALSE
graphREND	=	FALSE
#	controls if the render time-based outputs should be created
textDRIV	=	FALSE
graphDRIV	=	FALSE
#	controls if the driver lag-based outputs should be created

textAPI		=	FALSE
textLOC		=	FALSE
#	will generate TXT and HTML, if HTML is enabled, files for each API/Location

textDiff	=	FALSE
graphDiff	=	FALSE
#	controls if the display consecutive difference-based outputs should be created
#	cannot be DIFF because of naming conflict in Output

if (!textOUT)	{
	textFRAM	=	FALSE
	textDISP	=	FALSE
	textREND	=	FALSE
	HTMLOUT		=	FALSE
	textDiff	=	FALSE
}
#	turns off all of the text outputs, if it is not desired

if (!graphs)	{
	graphFRAM	=	FALSE
	graphDISP	=	FALSE
	graphREND	=	FALSE
	graphDRIV	=	FALSE
	graphDiff	=	FALSE
}
#	turns off all of the graph outputs, if it is not desired

if (interactive())	{
	setwd("!PATH!")
}	else	{
	pdf(NULL)
}
#	checks if the script is being run in the GUI or not
#		prevents rplots.pdf from being generated by ggplots2

resultsFull	=	read_csv("@Combined - !QUA!.csv")
#	loads in the CSV to the resultsFull variable

listGPU		=	c(
"RX 580",
"RX Vega 64",
"GTX 770",
"GTX 980",
"GTX 1070",
"GTX 1080",
"RTX 2060",
"RTX 2080"
)
#	list of the GPUs

listQUA		=	c(
"!QUA!"
)
#	list of the Qualities, but should always be just one element

listLOC		=	c(
!LOC!
)
#	list of locations for the data

shortLOC	=	c(
!LOCSHO!
)
#	list of the shortened location names for the data

listAPI		=	c(
!API!
)
#	list of the APIs for the data

shortAPI	=	c(
!APISHO!
)
#	list of the shortened API names for the data

resultsFull$GPU		=	ordered(resultsFull$GPU, levels = listGPU)
resultsFull$Quality	=	ordered(resultsFull$Quality, levels = listQUA)
if (length(listLOC[1]) != 0) {
	resultsFull$Location = ordered(resultsFull$Location, levels = listLOC)
}
resultsFull$API		=	ordered(resultsFull$API, levels = listAPI)
#	for desired ordering, values should be made factors and then have their levels ordered
#	the ordered function implies the factors should be ordered, and thus the ordered = TRUE argument is not needed
#		in case list of locations is empty, it will not make the values factors

results = resultsFull
#	with the factor levels set, a copy of resultsFull is saved to results
#		this way a complete and formatted copy of the data is protected and results can be a subset of it

multiGPU	=	is.null(cGPU)
#	checks if the current GPU variable is NULL, and then stores the result of that check to the multiGPU variable
labsGPU		=	labs(caption = cGPU)
if (multiGPU)	labsGPU	=	labs()
#	in single-GPU situations, a caption is added to the graphs to identify it
#		a default value is set to apply this caption and then removed in multiGPU situations

levsLOC	=	listLOC
if	(useSHORT	&	!is.null(shortLOC))	levsLOC	=	shortLOC
levsAPI	=	listAPI
if	(useSHORT	&	!is.null(shortAPI))	levsAPI	=	shortAPI
#	lists of levels for Location and API are made for use when applying shortened names
#		by default, these level lists are the original lists, so they can always be applied

overAPI	=	TRUE
#	overAPI is a variable that stores if testAPI has been overriden
#		it needs a value, so it is set to TRUE here, but is changed to FALSE if the override was not used
if	(!testAPI)	{
#	if testAPI is FALSE, then the following test for number of APIs is done
#	if testAPI is true TRUE, then the script continues with testAPI being TRUE
	testAPI		=	(length(unique(results$API)) >= 2)
#		checks if there are multiple APIs in the data, and therefore if they should be tested
	overAPI		=	FALSE
#		if testAPI was not overridden, overAPI will be made FALSE

GROUPS	=	list(GPU = results$GPU, Location = results$Location)
if	(testAPI)	GROUPS	=	list(GPU = results$GPU, API = results$API, Location = results$Location)
#	creates the groups for use with the by and aggregate functions here and in Output.r
#		by using an actual list, not just a vector, the column names for the groups can be set here
#		as GROUPS will always be used, a value is set and then changed if appropriate

diff.CONS	=	function(DATA, DIR = "Forward")	{
	if	(DIR == "Forward")	return(c(diff(DATA), 0))
	if	(DIR == "Backward")	return(c(0, diff(DATA)))
}
#	modification to the diff function, adding a 0 to the beginning or end to match the input data length
#		I prefer Forward, so the sum point to the next value, whereas Backward points to the previous

if (textDiff	|	graphDiff)	{
	results$MsDifferencePresents		=	unlist(by(results$MsBetweenPresents, GROUPS, diff.CONS))
	results$MsDifferenceDisplayChange	=	unlist(by(results$MsBetweenDisplayChange, GROUPS, diff.CONS))
}
#	the by function will apply a function to the contents of a data frame in groups, set by the GROUPS variable
#	it is very similar to the aggregate function, but returns a by class value, so unlist is needed to make it usable
#		this method is much faster and more efficient than using loops

DESC	=	function(ITEM = NULL)	{
	QUA		=	"Review"
	gameQ	=	paste0(game, " - Review")
	if (levels(results$Quality)[1] != "Review")	{
		QUA		=	paste0(levels(results$Quality)[1])
		gameQ	=	paste0(game,	" - ",	QUA, " Quality")
	}

	desc	=	""
	if	(!multiGPU)											desc	=	paste0(desc,	" - ",	cGPU)
	if	((!testAPI	&	all(listAPI != ""))	|	overAPI)	desc	=	paste0(desc,	" - ",	unique(results$API))

	gameGAQF	=	paste0(gameF,	desc,	" - ",	QUA)
	gameGAQ		=	paste0(game,	desc,	" - ",	QUA,	" Quality")

	if	(!is.null(ITEM))	{
		gameGAQF	=	paste0(gameGAQF,	" - ",	ITEM)
		gameGAQ		=	paste0(gameGAQ,		" - ",	ITEM)
	}
	return(c(gameGAQF,	gameGAQ, gameQ))
}
#	custom function for creating the gameGAQF, gameQAG, and gameQ values
#		these are all strings for identifying the configuration
#	making it a custom function helps when subsetting the data
#		the ITEM argument for the subsetting item
gameGAQF	=	DESC()[1]	;	gameGAQ		=	DESC()[2]	;	gameQ	=	DESC()[3]
#	sets the values
#		this does call the function multiple times, but the solution would be an intermediate variable

INDIV	=	function(TYPE, LIST, useSHORT = useSHORT, gWIDTH = gWIDTH, gHEIGH = gHEIGH)	{
#	arguments are present for applying specific height and width values for output graphs, and if shortened names should be used
	if	(TYPE != "GPU")	dir.create(paste0("@", TYPE))
#		when not subsetting by GPU, a folder will be made to hold the outputs
#			@ is placed at the front of the folder name to place it at the top of the directory view
	for	(ITEM in LIST)	{
		# TYPE	<<-	TYPE
		# LIST	<<-	LIST
		# ITEM	<<-	ITEM
		#	helpful for troubleshooting as values are available outside the function
		
		
		message(paste0("\n", ITEM))
#			displays a message to identify the current item being used for subsetting
		results	=	resultsFull[resultsFull[, TYPE] == ITEM, ]
#			creates a subset of the complete results based on the TYPE (column name) and the current value
#			Output.r accepts 'results' which is why that variable should be used
		if (nrow(results)	==	0)	next
#			makes sure there are data in the subset
		if (TYPE == "GPU" & length(unique(results$API)) == 1)	next
#			prevents single-GPU, single-API subsets from being used, as those would be the same result as working with more specific configurations

		if	(TYPE != "GPU")	{
			FOLD	=	paste0("@", TYPE, "/", ITEM)
			dir.create(FOLD)
		}
#			creates a folder for the specific ITEM of the current subset
#			will not do this for GPUs as there are already folders for them

		gameGAQF	=	DESC()[1]	;	gameGAQ		=	DESC()[2]	;	gameQ	=	DESC()[3]
#			assigns new values to these naming variables based on the current subset
		if (TYPE == "GPU")	{
			gameGAQF	=	paste0(ITEM, "/", gameGAQF)
		}	else	{
			gameGAQF	=	paste0(FOLD, "/", gameGAQF)
		}
#			gameGAQF is for file names, so this adds the appropriate folder information at the front, so the files are placed correctly

		perGPU	=	FALSE
#			to disable the generation of stats files for GPU subsets
#				the Output.r script does this and will throw errors in some situations
		source("@Combined - Output.r",	local = TRUE)
#			runs the Output.r script
#			local = TRUE is necessary so the script will be given the variable values set within the INDIV function
#			local = FALSE, the default, uses values from the global environment
	}
}
#	custom function to work through subsets of the results based on supplied lists
#		this will create both graph and text outputs for each subset

perGPU	=	TRUE
#	to disable the generation of stats files for GPU subsets
#		the Output.r script does this and will throw errors in some situations
if (!multiGPU)	perGPU	=	FALSE
#	turns off perGPU for single-GPU situations
source("@Combined - Output.r")
#	calls the Output.r script

if	(graphs_all)	{
# INDIV("GPU",		listGPU,	useSHORT = TRUE,	gWIDTH = gWIDTH * 1.25,	gHEIGH = gHEIGH * 2)
# INDIV("Location",	listLOC,	useSHORT = FALSE,	gWIDTH = gWIDTH * 1.25,	gHEIGH = gHEIGH * 1)
# INDIV("API",		listAPI,	useSHORT = TRUE,	gWIDTH = gWIDTH * 1.25,	gHEIGH = gHEIGH * 1)
}
#	examples of INDIV for subsetting by the list of GPUs, Locations, and API